[{"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/index.js":"1","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/store/store.js":"2","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Root.js":"3","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/root_reducer.js":"4","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/App.js":"5","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Splash.js":"6","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/entities_reducer.js":"7","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Navbar.js":"8","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/UserCurrent.js":"9","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/PlansMain.js":"10","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js":"11","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/plans_reducer.js":"12","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Portfolio.js":"13","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/DonutChart.js":"14","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/portfolio_actions.js":"15","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/plan_actions.js":"16"},{"size":276,"mtime":1609117308988,"results":"17","hashOfConfig":"18"},{"size":453,"mtime":1608570164388,"results":"19","hashOfConfig":"18"},{"size":282,"mtime":1608417750379,"results":"20","hashOfConfig":"18"},{"size":190,"mtime":1608410935676,"results":"21","hashOfConfig":"18"},{"size":591,"mtime":1610058689662,"results":"22","hashOfConfig":"18"},{"size":367,"mtime":1609117308959,"results":"23","hashOfConfig":"18"},{"size":274,"mtime":1608570164386,"results":"24","hashOfConfig":"18"},{"size":2064,"mtime":1611594945290,"results":"25","hashOfConfig":"18"},{"size":15958,"mtime":1611594490283,"results":"26","hashOfConfig":"18"},{"size":1646,"mtime":1610520451154,"results":"27","hashOfConfig":"18"},{"size":328,"mtime":1608570164388,"results":"28","hashOfConfig":"18"},{"size":618,"mtime":1608829840489,"results":"29","hashOfConfig":"18"},{"size":1357,"mtime":1611592364270,"results":"30","hashOfConfig":"18"},{"size":1811,"mtime":1610132408019,"results":"31","hashOfConfig":"18"},{"size":904,"mtime":1608570164382,"results":"32","hashOfConfig":"18"},{"size":465,"mtime":1608829840485,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1s6bjhd",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"36"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"36"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/index.js",[],["71","72"],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/store/store.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Root.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/root_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/App.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Splash.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/entities_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Navbar.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/UserCurrent.js",["73","74"],"import React, { useState, useEffect } from 'react';\nimport { useSelector } from 'react-redux';\nimport { Link } from 'react-router-dom';\n\nimport '../stylesheets/userCurrent.css';\n\nfunction UserInfo() {\n  const currPlan = useSelector(state => state.entities.plans)[0];\n  const headers = currPlan ? Object.keys(currPlan).filter(hdrs => hdrs !== \"Risk\"): [];\n\n  // consider storing user's (valid entries) portfolio to store\n  const [ userPortfolio, setUserPortfolio ] = useState({});\n  const [ inputErrors, setInputErrors ] = useState({}); //modifying a set repeatedly will likely be costly\n\n  const [ recPortfolio, setRecPortfolio ] = useState({});\n  const [ recTransfers, setRecTransfers ] = useState([]);  \n\n\n  // componentDidMount - set base for user's info & recommended info\n  useEffect(() => {\n    const stateVars = {};\n    headers.forEach(ctg => {\n      stateVars[ctg] = 0.0;\n    })\n    setUserPortfolio(stateVars);\n  }, [])\n\n  function updateAmount(category) {\n    return e => {\n      //figure out regex solution if you have time\n      // const entered = e.currentTarget.value.replace(/,/g, \"\"); \n\n      //when potentially fixing error, clear the error\n      if ( inputErrors[category] ) {\n        const tempErrors = Object.assign({}, inputErrors);\n        delete tempErrors[category];\n        setInputErrors(tempErrors);\n      }\n\n      let entered = e.currentTarget.value.split(\".\");\n\n      //checks for valid number entered: max two decimal places, adjust for $ sign. Use better validity checks!!  //if length of decimal is more than 2, must be === 0 or parseFloat will make length less than 2 (meaning 0s only after 2nd decimal)\n      if (entered.length > 2) return setInputErrors(Object.assign({}, inputErrors, { [category]: true })) //consider using a set for errors\n      if (entered.length === 2) {\n        if(entered[1].length > 2 || (isNaN(entered[1]) && entered[1] !== \"\")) return setInputErrors(Object.assign({}, inputErrors, { [category]: true }))\n      };\n\n      if (entered[0][0] === \"$\") entered[0] = entered[0].slice(1);\n      \n      // check validity: appropriate commas\n      for (let i = entered[0].length-4; i > 0; i-=4) { \n        if (entered[0][i] === \",\") entered[0] = entered[0].slice(0, i) + entered[0].slice(i+1); \n        else break;\n      }\n\n      if (entered.join(\".\") === \"\") {\n        setUserPortfolio(Object.assign({}, userPortfolio, {[category]: 0.0}));\n      } else if (!isNaN(entered.join(\".\"))){\n        const newState = Object.assign({}, userPortfolio);\n        newState[category] = parseFloat(entered.join(\".\"));\n        setUserPortfolio(newState);\n      } else {\n        setInputErrors(Object.assign({}, inputErrors, { [category]: true }))\n      }\n    }\n  }\n\n  function confirmValid() {\n    // confirm no errors, confirm at least one entry entered\n    if (Object.keys(inputErrors).length || !Object.values(userPortfolio).some(ele => ele)) return false;\n    else return true;\n  }\n\n  // insertionSort (quicker sort for small sized array)\n  function _insertionSort (inputArr) {\n    let length = inputArr.length;\n    for (let i = 1; i < length; i++) {\n      let key = inputArr[i];\n      let j = i-1;\n      while (j >= 0 && inputArr[j] > key) {\n        inputArr[j+1] = inputArr[j];\n        j = j-1;\n      }\n      inputArr[j+1] = key;\n    }\n    return inputArr;\n  }\n\n  //find subset of sums\n  let sums = {}; //key:val => {length of smallest combo: array of subarray sums} \n  function _subsetSum(arr, target, partial = [], sum = 0, fixIdx = 0) { \n    if (sum < target) {\n      arr.forEach((num, i) => {\n        _subsetSum(arr.slice(i + 1), target, partial.concat([i + fixIdx]), sum + num, i+1)\n      })\n    }\n    else if (sum === target) {\n      fixIdx = 0;\n      if (sums[partial.length]) sums[partial.length].push(partial);\n      else sums[partial.length] = [partial];\n    }\n    else fixIdx = 0;\n  }\n\n  //returns matching index or index of last element less than target\n  function _modBSearch(arr, target) {\n    if (target < arr[0]) return -1; //used to avoid split transfers until necessary\n    if (target > arr[arr.length-1]) return arr.length-1;\n\n    let mid;\n    let left = 0;\n    let right = arr.length;\n    \n    while (left < right) {\n      mid = Math.floor((left + right)/2);\n      if (arr[mid] === target) return mid;\n      if (arr[mid] < target) left = mid+1;\n      else right = mid;\n    }\n\n    return -1;  //temporary fix until modbsearch fixed. target not in array\n    // return mid;\n  } \n\n  // FIX THIS LATER TO A BETTER SEARCH\n  function _findLargestNeg(arr) {\n    let left = 0;\n    let right = arr.length-1;\n    let mid;\n\n    while (left < right) {\n      mid = Math.floor((left + right)/2);\n\n      if (arr[mid] < 0 && arr[mid+1] > 0) return mid;\n      if (arr[mid] > 0) right = mid;\n      else if (arr[mid] < 0 && arr[mid+1] < 0) left = mid;\n    }\n  }\n\n    // const permutator = (inputArr) => {\n    //   let result = [];\n\n    //   const permute = (arr, m = []) => {\n    //     if (arr.length === 0) {\n    //       result.push(m)\n    //     } else {\n    //       for (let i = 0; i < arr.length; i++) {\n    //         let curr = arr.slice();\n    //         let next = curr.splice(i, 1);\n    //         permute(curr.slice(), m.concat(next))\n    //       }\n    //     }\n    //   }\n\n    //   permute(inputArr)\n    //   return result;\n    // }\n\n\n  function calculate(e) {\n    e.preventDefault();\n\n    if (confirmValid()) {\n      // Research accounting concepts\n\n      //Establish recommended portfolio based on user input\n      const total = Object.values(userPortfolio).reduce((subTotal, float) => {\n        if (float) return subTotal + parseFloat(float);\n        else return subTotal;\n      }, 0.0)\n\n      const makeRecPortfolio = {};\n      const recTrans = []; //Array of subarrays. \n        //First element of subarray = amount needed from fund(s); if int, matching subset of excess accounts; if array, partial transfers needed. \n        //Second element of subarray = excess amts; if int, matching subset of below value accts; if array, partial transfers needed.\n\n      // variables to be used for referencing which categories transfers will come from\n      const lessThanRec = {}; //key/value => amount needed: category      ---> none of these categories should transfer out\n      const moreThanRec = {}; //key/value => amount extra: category\n\n      let offAmounts = []; //To be sorted array of all amounts needed and excess\n      let largestNeg; //To be largest negative value (for quicker slicing & stop points)\n\n      // Determine \"offAmounts\". Set values to amounts short/in excess and log accounts\n      headers.forEach(ctg => {\n        makeRecPortfolio[ctg] = Math.round(((parseInt(currPlan[ctg])/100 * total) + Number.EPSILON) * 100) / 100; //review this calculation for simplification\n        if (makeRecPortfolio[ctg] === userPortfolio[ctg]) return; //no transfers needed\n\n        if (makeRecPortfolio[ctg] > userPortfolio[ctg]) {\n          const setNumber = Math.round((makeRecPortfolio[ctg] - userPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (lessThanRec[setNumber]) lessThanRec[setNumber].push(ctg);\n          else lessThanRec[setNumber] = [ctg];\n          offAmounts.push(setNumber * -1); \n        }\n        else {\n          const setNumber = Math.round((userPortfolio[ctg] - makeRecPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (moreThanRec[setNumber]) moreThanRec[setNumber].push(ctg);\n          else moreThanRec[setNumber] = [ctg];\n          offAmounts.push(setNumber);\n        }\n      })\n      setRecPortfolio(makeRecPortfolio);\n\n      if (!Object.keys(moreThanRec).length) return setRecTransfers([\"No transfers needed, your portfolio is optimal!\"]); //no transfers needed - portfolio matches recommended plan\n\n      _insertionSort(offAmounts); //sort off amounts\n      largestNeg = _findLargestNeg(offAmounts); //initial declaration of largest negative\n      // largestNeg = _modBSearch(offAmounts, 0); //initial declaration of largest negative\n\n      let posOffAmounts = offAmounts.slice(largestNeg+1); //avoid constant slicing if unnecessary\n      let negOffAmounts = offAmounts.slice(0, largestNeg+1);\n      \n      // first grab any matching differences\n      for (let i = 0; i <= largestNeg; i++) {\n        const current = Math.abs(offAmounts[i]);\n        const matchIndex = _modBSearch(posOffAmounts, current) + largestNeg + 1;\n\n        //NEED TO FIX MODBSEARCH\n        if (i === matchIndex) continue;\n\n        if (current === offAmounts[matchIndex]) {\n          recTrans.push([current, offAmounts[matchIndex]]);\n          offAmounts = offAmounts.slice(0, i).concat(offAmounts.slice(i+1, matchIndex)).concat(offAmounts.slice(matchIndex+1)); //adjust for element being removed\n          largestNeg = largestNeg - 1; \n          negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          posOffAmounts = offAmounts.slice(largestNeg+1)\n          i--; \n        }\n      }\n\n\n      // next grab any owed combo with singular excess\n        // if one lessThan acct or one moreThan acct, \n        // else remaining cannot be broken down further (THIS IS ONLY BECAUSE OF THE LIMITED NUM OF ACCTS. If more num of accts, find matching for smallest num of excess summed == smallest num of neg summed.)\n        if (posOffAmounts.length === 1 || negOffAmounts.length === 1) {\n          if (negOffAmounts.length === 1) recTrans.push([Math.abs(negOffAmounts[0]), posOffAmounts]);\n          else recTrans.push([negOffAmounts.map(amt => Math.abs(amt)), posOffAmounts[0]]);\n        } else {\n          recTrans.push([negOffAmounts.map(amt => Math.abs(amt)), posOffAmounts]);\n\n          // let bestNum = negOffAmounts.length;\n          // let bestRec = [];\n          // let bestExcessIdx = offAmounts.length-1;\n          // let bestIndices = []; //for slicing\n\n          // for (let i = offAmounts.length-1; i > largestNeg; i--) {\n          //   sums = {}; //reassign sums for each iteration\n\n          //   _subsetSum(negOffAmounts, offAmounts[i] * -1);\n\n          //   let cost = parseInt(Object.keys(sums)[0]);\n          //   if (bestNum > cost) {\n          //     bestNum = cost;\n          //     bestExcessIdx = i;\n          //     bestIndices = sums[cost].pop(); \n          //   }\n          // }\n\n          // // confirmed, best group is the best of this iteration\n          // if (Object.keys(sums).length) { \n          //   for (let i = bestIndices.length-1; i >= 0; i--) {\n          //     bestRec.push(offAmounts[i]);\n          //     offAmounts = offAmounts.slice(0, i+1).concat(offAmounts.slice(i+1));\n          //   }\n\n          //   bestExcessIdx -= bestIndices.length; //adjust for sliced negs\n          //   recTrans.push([bestRec, offAmounts[bestExcessIdx]]); //can sum for offAmounts[bestExcessIdx], but use index for QA\n          //   offAmounts = offAmounts.slice(0, bestExcessIdx).concat(offAmounts.slice(bestExcessIdx+1));\n          //   largestNeg = largestNeg - bestIndices.length;\n          //   posOffAmounts = offAmounts.slice(largestNeg+1);\n          //   negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          // }\n      }\n\n\n      //transfer to text values\n      let recommendText = [];\n      recTrans.forEach(subArr => {\n        let owed = subArr[0];\n        let excess = subArr[1];\n        if (!(owed instanceof Array) && !(excess instanceof Array)) {\n          recommendText.push(`Transfer $${owed} from ${moreThanRec[excess].pop()} to ${lessThanRec[owed].pop()}.`)\n        }\n        else if (owed instanceof Array && !(excess instanceof Array)) {\n          const singleAcct = moreThanRec[excess].pop();\n          owed.forEach(oweAmt => {\n            recommendText.push(`Transfer $${oweAmt} from ${singleAcct} to ${lessThanRec[oweAmt].pop()}.`);\n          })\n        }\n        else if (!(owed instanceof Array) && excess instanceof Array) {\n          const singleAcct = lessThanRec[owed].pop();\n          excess.forEach(excessAmt => {\n            recommendText.push(`Transfer $${excessAmt} from ${moreThanRec[excessAmt].pop()} to ${singleAcct}.`);\n          })\n        }\n        else { //both arrays\n          let currExcess = excess.pop();\n          let currOwed = owed.pop();\n\n          let currExcessAcct = moreThanRec[currExcess].pop();\n          let currOwedAcct = lessThanRec[currOwed].pop();\n\n          while (currExcess || currOwed) {\n            let deduct = Math.min(currExcess, currOwed);\n            recommendText.push(`Transfer $${deduct} from ${currExcessAcct} to ${currOwedAcct}.`);\n\n            currExcess = Math.floor((currExcess - deduct) * 1000)/1000;\n            currOwed = Math.floor((currOwed - deduct) * 1000)/1000;\n\n            if (currExcess) {\n              currOwed = owed.pop();\n              currOwedAcct = lessThanRec[currOwed].pop();\n            } else if (currOwed) {\n              currExcess = excess.pop();\n              currExcessAcct = moreThanRec[currExcess].pop();\n            } else break; //unnecessary break\n          }\n        }\n      })\n\n      setRecTransfers(recommendText);\n\n    }\n    else console.log(\"Review Errors\")\n  }\n\n  return (\n    \n    <div className=\"personalize-main-div\">\n      <div className=\"user-img\"></div>\n\n      <h1>Personalize Your Portfolio</h1>\n\n      <div className=\"personalize-div-wrapper\">\n        <div className=\"personalize-right\">\n          <section className=\"risk-section\">\n            { currPlan ? (\n              <div>\n                <h4 id=\"risk-section-header\">Risk Level {currPlan['Risk']}</h4>\n                { headers.map(ctg => (\n                  <div key={ctg}>\n                    <span>{ctg}</span>\n                    <span>{currPlan[ctg]}%</span>\n                  </div>\n                )) }\n              </div>\n            ) : <Link to=\"/plans\">Choose a plan that's right for you!</Link> }\n          </section>\n\n          { recTransfers.length ? (\n            <div className=\"recommended-trans-div\">\n              <h3>Recommended Transfers: </h3>\n              { recTransfers.map((text, idx) => (\n                  <p key={`text-${idx}`}>- {text}</p>\n              ))}\n            </div>\n          ) : null }\n        </div>\n\n        <div className=\"personalize-left\">\n          <div className=\"personalize-risk-section\">\n            <h3>Tell us about your current portfolio: </h3>\n            <form onSubmit={calculate}>\n              { headers.map(ctg => {\n                let recDiff;\n                let color; \n                let arrow; \n                let ctgErr = inputErrors[ctg] ? `${ctg}-input-errors` : \"\";\n                \n                if (Object.keys(recPortfolio).length) {\n                  recDiff = (recPortfolio[ctg] - userPortfolio[ctg]) ? recPortfolio[ctg] - userPortfolio[ctg] : null;\n                  color = recDiff > 0 ? \"green\" : \"red\";\n                  arrow = recDiff > 0 ? <i className=\"fas fa-arrow-up\"></i> : <i className=\"fas fa-arrow-down\"></i>;\n                }\n                return (\n                  <div key={ctg} className={`${ctg}-div personalize-input-div`}>\n                    <label htmlFor={ctg}>{ctg}</label>\n                    <input type=\"text\" \n                      onChange={updateAmount(ctg)}\n                      className={ctgErr}\n                    />\n                    { recDiff || recDiff === 0 ? <span className={`rec-${color}`}>{arrow} $ {Math.abs(recDiff).toFixed(2)}</span> : null }\n                  </div>\n                )\n              }) }\n\n              <button>Calculate My Plan!</button>\n            </form>\n            \n          </div>\n          { Object.keys(recPortfolio).length ? (\n\n            <div className=\"recommended-plan-div\">\n              <h3>Recommended Plan</h3>\n              {headers.map((ctg, idx) => {\n                return (\n                  <div key={`${ctg}-${idx}`}>\n                    <span>{ctg}:</span>\n                    <span>$ {recPortfolio[ctg]}</span>\n                  </div>\n                )\n              })}\n            </div>\n\n          ) : null }\n\n        </div>\n      </div>\n\n    </div>\n  )\n}\n\nexport default UserInfo;","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/PlansMain.js",["75"],"import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { Link } from 'react-router-dom';\nimport Highcharts from 'highcharts';\n\nimport Portfolio from './Portfolio';\nimport DonutChart from './DonutChart';\n\nimport { grabPortfolios } from '../actions/portfolio_actions';\nimport { receivePlan } from '../actions/plan_actions';\n\nimport '../stylesheets/plansMain.css';\n\nfunction PlansMain(props) {\n  const dispatch = useDispatch();\n  const portfolios = useSelector(state => state.entities.portfolios.data)\n  const data = useSelector(state => state.entities.plans);\n\n  const donutPresent = data.length === 1 ? \"plans-split\" : \"\";\n\n  useEffect(() => {\n      dispatch(grabPortfolios());\n  }, []) //dispatch on initial mount\n\n  useEffect(() => {\n    const donut = data.length === 1 ? Highcharts.charts[Highcharts.charts.length-1] : \"\";\n    if (donut) donut.reflow();\n  }, [data.length])\n\n\n  return (\n    <div className=\"plans-main-div\">\n      <div className=\"label-header\">\n        <span>Select A Risk Plan</span>\n        { data.length ? <Link to=\"/personalize\">Calculate</Link> : null }\n      </div>\n      <div className={`plans-main-base ${donutPresent}`}>\n        <Portfolio \n          plans={portfolios} \n          chosenPlans={data}\n          selectPlan={(plan) => { dispatch(receivePlan(plan)) }}\n          // eventually add dispatch multiple plans\n        />\n\n        {/* eventually some button for compare options */}\n      </div>\n      <div className=\"plans-main-charts\">\n        { data.length === 1 ? <DonutChart data={data[0]}/> : null }\n      </div>\n    </div>\n  )\n}\n\nexport default PlansMain; \n","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/plans_reducer.js",["76"],"import { RECEIVE_PLAN, RECEIVE_PLANS, UNSELECT_PLAN, CLEAR_PLANS } from '../actions/plan_actions';\n\nconst plansReducer = (state = [], action) => {\n  Object.freeze(state);\n  let newState;\n\n  switch (action.type) {\n    case RECEIVE_PLAN: \n      newState = [action.plan]\n      return newState;\n    // case RECEIVE_PLANS: \n    //   newState = Object.assign([], state);\n    //   newState.push(action.plan)\n    //   return newState;\n    case UNSELECT_PLAN:\n      return state.filter(plans => plans === action.plan);\n    case CLEAR_PLANS:\n      return [];\n    default:\n      return state;\n  }\n\n}\n\nexport default plansReducer;","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Portfolio.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/DonutChart.js",["77"],"import React from 'react';\n\nimport Highcharts, { Point } from 'highcharts';\nimport HighchartsReact from 'highcharts-react-official';\n\nfunction DonutChart(props) {\n  const data = props.data; //Note: Object keys - 'Risk' is a key. \n  const colors = ['#555B6E', '#89B0AE', '#BEE3DB', '#FFD6BA', '#E89C87'];\n\n  // DONUT CHART PLANS #6 //////\n\n  const categories = data ? Object.keys(data).filter(ctg => ctg !== 'Risk') : [];\n\n  const options = data ? {\n    chart: {\n      type: 'pie',\n      renderTo: 'container',\n    },\n    title: {\n      text: `Risk Plan ${data ? data['Risk'] : \"\"}`,\n    },\n    plotOptions: {\n      pie: {\n        // shadow: true,\n        colors: colors,\n        allowPointSelect: true,\n        cursor: 'pointer',\n        dataLabels: {\n          enabled: true,\n          pointFormat: '<b>{point.plan}</b><br>{point.y}%',\n          distance: -50,\n          filter: {\n            property: 'percentage',\n            operator: '>',\n            value: 1\n          },\n        },\n        size: '85%',\n        center: ['50%', '40%'],\n      }\n    },\n    // yAxis: {\n    //   title: {\n    //     text: 'Y-AXIS'\n    //   }\n    // },\n    series: [\n      {\n        name: \"Plan\",\n        data: categories.map(key => { return {plan: key, y: parseInt(data[key])} }),\n        innerSize: '30%',\n      }\n    ],\n    tooltip: {\n      headerFormat: '<b>{point.plan}</b>',\n      pointFormat: '<b>{point.percentage}%</b>'\n    },\n    // credits: {\n    //   enabled: false\n    // }\n  } : null;\n\n  return (\n    // categories\n    <div className=\"donut-chart-div\">\n      { data ? \n        <HighchartsReact \n          highcharts={Highcharts} \n          options={options}      \n          containerProps={{style: {height: '100%',} }} // width: '50vw'} }}\n        />\n      : null }\n    </div>\n  );\n}\n\nexport default DonutChart;","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/portfolio_actions.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/plan_actions.js",[],{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","replacedBy":"81"},{"ruleId":"82","severity":1,"message":"83","line":26,"column":6,"nodeType":"84","endLine":26,"endColumn":8,"suggestions":"85"},{"ruleId":"86","severity":1,"message":"87","line":94,"column":9,"nodeType":"88","messageId":"89","endLine":94,"endColumn":19},{"ruleId":"82","severity":1,"message":"90","line":23,"column":6,"nodeType":"84","endLine":23,"endColumn":8,"suggestions":"91"},{"ruleId":"86","severity":1,"message":"92","line":1,"column":24,"nodeType":"88","messageId":"89","endLine":1,"endColumn":37},{"ruleId":"86","severity":1,"message":"93","line":3,"column":22,"nodeType":"88","messageId":"89","endLine":3,"endColumn":27},"no-native-reassign",["94"],"no-negated-in-lhs",["95"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'headers'. Either include it or remove the dependency array.","ArrayExpression",["96"],"no-unused-vars","'_subsetSum' is defined but never used.","Identifier","unusedVar","React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.",["97"],"'RECEIVE_PLANS' is defined but never used.","'Point' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"98","fix":"99"},{"desc":"100","fix":"101"},"Update the dependencies array to be: [headers]",{"range":"102","text":"103"},"Update the dependencies array to be: [dispatch]",{"range":"104","text":"105"},[925,927],"[headers]",[732,734],"[dispatch]"]