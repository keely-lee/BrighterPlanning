[{"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/index.js":"1","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/store/store.js":"2","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Root.js":"3","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/root_reducer.js":"4","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/App.js":"5","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Splash.js":"6","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/entities_reducer.js":"7","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Navbar.js":"8","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/UserCurrent.js":"9","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/PlansMain.js":"10","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js":"11","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/plans_reducer.js":"12","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Portfolio.js":"13","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/DonutChart.js":"14","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/portfolio_actions.js":"15","/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/plan_actions.js":"16"},{"size":276,"mtime":1609117308988,"results":"17","hashOfConfig":"18"},{"size":453,"mtime":1608570164388,"results":"19","hashOfConfig":"18"},{"size":282,"mtime":1608417750379,"results":"20","hashOfConfig":"18"},{"size":190,"mtime":1608410935676,"results":"21","hashOfConfig":"18"},{"size":591,"mtime":1610058689662,"results":"22","hashOfConfig":"18"},{"size":367,"mtime":1609117308959,"results":"23","hashOfConfig":"18"},{"size":274,"mtime":1608570164386,"results":"24","hashOfConfig":"18"},{"size":2063,"mtime":1611594924391,"results":"25","hashOfConfig":"18"},{"size":15958,"mtime":1611594490283,"results":"26","hashOfConfig":"18"},{"size":1646,"mtime":1610520451154,"results":"27","hashOfConfig":"18"},{"size":328,"mtime":1608570164388,"results":"28","hashOfConfig":"18"},{"size":618,"mtime":1608829840489,"results":"29","hashOfConfig":"18"},{"size":1357,"mtime":1611592364270,"results":"30","hashOfConfig":"18"},{"size":1811,"mtime":1610132408019,"results":"31","hashOfConfig":"18"},{"size":904,"mtime":1608570164382,"results":"32","hashOfConfig":"18"},{"size":465,"mtime":1608829840485,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"3y7m0u",{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"53"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/index.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/store/store.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Root.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/root_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/App.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Splash.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/entities_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Navbar.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/UserCurrent.js",["68","69"],"import React, { useState, useEffect } from 'react';\nimport { useSelector } from 'react-redux';\nimport { Link } from 'react-router-dom';\n\nimport '../stylesheets/userCurrent.css';\n\nfunction UserInfo() {\n  const currPlan = useSelector(state => state.entities.plans)[0];\n  const headers = currPlan ? Object.keys(currPlan).filter(hdrs => hdrs !== \"Risk\"): [];\n\n  // consider storing user's (valid entries) portfolio to store\n  const [ userPortfolio, setUserPortfolio ] = useState({});\n  const [ inputErrors, setInputErrors ] = useState({}); //modifying a set repeatedly will likely be costly\n\n  const [ recPortfolio, setRecPortfolio ] = useState({});\n  const [ recTransfers, setRecTransfers ] = useState([]);  \n\n\n  // componentDidMount - set base for user's info & recommended info\n  useEffect(() => {\n    const stateVars = {};\n    headers.forEach(ctg => {\n      stateVars[ctg] = 0.0;\n    })\n    setUserPortfolio(stateVars);\n  }, [])\n\n  function updateAmount(category) {\n    return e => {\n      //figure out regex solution if you have time\n      // const entered = e.currentTarget.value.replace(/,/g, \"\"); \n\n      //when potentially fixing error, clear the error\n      if ( inputErrors[category] ) {\n        const tempErrors = Object.assign({}, inputErrors);\n        delete tempErrors[category];\n        setInputErrors(tempErrors);\n      }\n\n      let entered = e.currentTarget.value.split(\".\");\n\n      //checks for valid number entered: max two decimal places, adjust for $ sign. Use better validity checks!!  //if length of decimal is more than 2, must be === 0 or parseFloat will make length less than 2 (meaning 0s only after 2nd decimal)\n      if (entered.length > 2) return setInputErrors(Object.assign({}, inputErrors, { [category]: true })) //consider using a set for errors\n      if (entered.length === 2) {\n        if(entered[1].length > 2 || (isNaN(entered[1]) && entered[1] !== \"\")) return setInputErrors(Object.assign({}, inputErrors, { [category]: true }))\n      };\n\n      if (entered[0][0] === \"$\") entered[0] = entered[0].slice(1);\n      \n      // check validity: appropriate commas\n      for (let i = entered[0].length-4; i > 0; i-=4) { \n        if (entered[0][i] === \",\") entered[0] = entered[0].slice(0, i) + entered[0].slice(i+1); \n        else break;\n      }\n\n      if (entered.join(\".\") === \"\") {\n        setUserPortfolio(Object.assign({}, userPortfolio, {[category]: 0.0}));\n      } else if (!isNaN(entered.join(\".\"))){\n        const newState = Object.assign({}, userPortfolio);\n        newState[category] = parseFloat(entered.join(\".\"));\n        setUserPortfolio(newState);\n      } else {\n        setInputErrors(Object.assign({}, inputErrors, { [category]: true }))\n      }\n    }\n  }\n\n  function confirmValid() {\n    // confirm no errors, confirm at least one entry entered\n    if (Object.keys(inputErrors).length || !Object.values(userPortfolio).some(ele => ele)) return false;\n    else return true;\n  }\n\n  // insertionSort (quicker sort for small sized array)\n  function _insertionSort (inputArr) {\n    let length = inputArr.length;\n    for (let i = 1; i < length; i++) {\n      let key = inputArr[i];\n      let j = i-1;\n      while (j >= 0 && inputArr[j] > key) {\n        inputArr[j+1] = inputArr[j];\n        j = j-1;\n      }\n      inputArr[j+1] = key;\n    }\n    return inputArr;\n  }\n\n  //find subset of sums\n  let sums = {}; //key:val => {length of smallest combo: array of subarray sums} \n  function _subsetSum(arr, target, partial = [], sum = 0, fixIdx = 0) { \n    if (sum < target) {\n      arr.forEach((num, i) => {\n        _subsetSum(arr.slice(i + 1), target, partial.concat([i + fixIdx]), sum + num, i+1)\n      })\n    }\n    else if (sum === target) {\n      fixIdx = 0;\n      if (sums[partial.length]) sums[partial.length].push(partial);\n      else sums[partial.length] = [partial];\n    }\n    else fixIdx = 0;\n  }\n\n  //returns matching index or index of last element less than target\n  function _modBSearch(arr, target) {\n    if (target < arr[0]) return -1; //used to avoid split transfers until necessary\n    if (target > arr[arr.length-1]) return arr.length-1;\n\n    let mid;\n    let left = 0;\n    let right = arr.length;\n    \n    while (left < right) {\n      mid = Math.floor((left + right)/2);\n      if (arr[mid] === target) return mid;\n      if (arr[mid] < target) left = mid+1;\n      else right = mid;\n    }\n\n    return -1;  //temporary fix until modbsearch fixed. target not in array\n    // return mid;\n  } \n\n  // FIX THIS LATER TO A BETTER SEARCH\n  function _findLargestNeg(arr) {\n    let left = 0;\n    let right = arr.length-1;\n    let mid;\n\n    while (left < right) {\n      mid = Math.floor((left + right)/2);\n\n      if (arr[mid] < 0 && arr[mid+1] > 0) return mid;\n      if (arr[mid] > 0) right = mid;\n      else if (arr[mid] < 0 && arr[mid+1] < 0) left = mid;\n    }\n  }\n\n    // const permutator = (inputArr) => {\n    //   let result = [];\n\n    //   const permute = (arr, m = []) => {\n    //     if (arr.length === 0) {\n    //       result.push(m)\n    //     } else {\n    //       for (let i = 0; i < arr.length; i++) {\n    //         let curr = arr.slice();\n    //         let next = curr.splice(i, 1);\n    //         permute(curr.slice(), m.concat(next))\n    //       }\n    //     }\n    //   }\n\n    //   permute(inputArr)\n    //   return result;\n    // }\n\n\n  function calculate(e) {\n    e.preventDefault();\n\n    if (confirmValid()) {\n      // Research accounting concepts\n\n      //Establish recommended portfolio based on user input\n      const total = Object.values(userPortfolio).reduce((subTotal, float) => {\n        if (float) return subTotal + parseFloat(float);\n        else return subTotal;\n      }, 0.0)\n\n      const makeRecPortfolio = {};\n      const recTrans = []; //Array of subarrays. \n        //First element of subarray = amount needed from fund(s); if int, matching subset of excess accounts; if array, partial transfers needed. \n        //Second element of subarray = excess amts; if int, matching subset of below value accts; if array, partial transfers needed.\n\n      // variables to be used for referencing which categories transfers will come from\n      const lessThanRec = {}; //key/value => amount needed: category      ---> none of these categories should transfer out\n      const moreThanRec = {}; //key/value => amount extra: category\n\n      let offAmounts = []; //To be sorted array of all amounts needed and excess\n      let largestNeg; //To be largest negative value (for quicker slicing & stop points)\n\n      // Determine \"offAmounts\". Set values to amounts short/in excess and log accounts\n      headers.forEach(ctg => {\n        makeRecPortfolio[ctg] = Math.round(((parseInt(currPlan[ctg])/100 * total) + Number.EPSILON) * 100) / 100; //review this calculation for simplification\n        if (makeRecPortfolio[ctg] === userPortfolio[ctg]) return; //no transfers needed\n\n        if (makeRecPortfolio[ctg] > userPortfolio[ctg]) {\n          const setNumber = Math.round((makeRecPortfolio[ctg] - userPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (lessThanRec[setNumber]) lessThanRec[setNumber].push(ctg);\n          else lessThanRec[setNumber] = [ctg];\n          offAmounts.push(setNumber * -1); \n        }\n        else {\n          const setNumber = Math.round((userPortfolio[ctg] - makeRecPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (moreThanRec[setNumber]) moreThanRec[setNumber].push(ctg);\n          else moreThanRec[setNumber] = [ctg];\n          offAmounts.push(setNumber);\n        }\n      })\n      setRecPortfolio(makeRecPortfolio);\n\n      if (!Object.keys(moreThanRec).length) return setRecTransfers([\"No transfers needed, your portfolio is optimal!\"]); //no transfers needed - portfolio matches recommended plan\n\n      _insertionSort(offAmounts); //sort off amounts\n      largestNeg = _findLargestNeg(offAmounts); //initial declaration of largest negative\n      // largestNeg = _modBSearch(offAmounts, 0); //initial declaration of largest negative\n\n      let posOffAmounts = offAmounts.slice(largestNeg+1); //avoid constant slicing if unnecessary\n      let negOffAmounts = offAmounts.slice(0, largestNeg+1);\n      \n      // first grab any matching differences\n      for (let i = 0; i <= largestNeg; i++) {\n        const current = Math.abs(offAmounts[i]);\n        const matchIndex = _modBSearch(posOffAmounts, current) + largestNeg + 1;\n\n        //NEED TO FIX MODBSEARCH\n        if (i === matchIndex) continue;\n\n        if (current === offAmounts[matchIndex]) {\n          recTrans.push([current, offAmounts[matchIndex]]);\n          offAmounts = offAmounts.slice(0, i).concat(offAmounts.slice(i+1, matchIndex)).concat(offAmounts.slice(matchIndex+1)); //adjust for element being removed\n          largestNeg = largestNeg - 1; \n          negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          posOffAmounts = offAmounts.slice(largestNeg+1)\n          i--; \n        }\n      }\n\n\n      // next grab any owed combo with singular excess\n        // if one lessThan acct or one moreThan acct, \n        // else remaining cannot be broken down further (THIS IS ONLY BECAUSE OF THE LIMITED NUM OF ACCTS. If more num of accts, find matching for smallest num of excess summed == smallest num of neg summed.)\n        if (posOffAmounts.length === 1 || negOffAmounts.length === 1) {\n          if (negOffAmounts.length === 1) recTrans.push([Math.abs(negOffAmounts[0]), posOffAmounts]);\n          else recTrans.push([negOffAmounts.map(amt => Math.abs(amt)), posOffAmounts[0]]);\n        } else {\n          recTrans.push([negOffAmounts.map(amt => Math.abs(amt)), posOffAmounts]);\n\n          // let bestNum = negOffAmounts.length;\n          // let bestRec = [];\n          // let bestExcessIdx = offAmounts.length-1;\n          // let bestIndices = []; //for slicing\n\n          // for (let i = offAmounts.length-1; i > largestNeg; i--) {\n          //   sums = {}; //reassign sums for each iteration\n\n          //   _subsetSum(negOffAmounts, offAmounts[i] * -1);\n\n          //   let cost = parseInt(Object.keys(sums)[0]);\n          //   if (bestNum > cost) {\n          //     bestNum = cost;\n          //     bestExcessIdx = i;\n          //     bestIndices = sums[cost].pop(); \n          //   }\n          // }\n\n          // // confirmed, best group is the best of this iteration\n          // if (Object.keys(sums).length) { \n          //   for (let i = bestIndices.length-1; i >= 0; i--) {\n          //     bestRec.push(offAmounts[i]);\n          //     offAmounts = offAmounts.slice(0, i+1).concat(offAmounts.slice(i+1));\n          //   }\n\n          //   bestExcessIdx -= bestIndices.length; //adjust for sliced negs\n          //   recTrans.push([bestRec, offAmounts[bestExcessIdx]]); //can sum for offAmounts[bestExcessIdx], but use index for QA\n          //   offAmounts = offAmounts.slice(0, bestExcessIdx).concat(offAmounts.slice(bestExcessIdx+1));\n          //   largestNeg = largestNeg - bestIndices.length;\n          //   posOffAmounts = offAmounts.slice(largestNeg+1);\n          //   negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          // }\n      }\n\n\n      //transfer to text values\n      let recommendText = [];\n      recTrans.forEach(subArr => {\n        let owed = subArr[0];\n        let excess = subArr[1];\n        if (!(owed instanceof Array) && !(excess instanceof Array)) {\n          recommendText.push(`Transfer $${owed} from ${moreThanRec[excess].pop()} to ${lessThanRec[owed].pop()}.`)\n        }\n        else if (owed instanceof Array && !(excess instanceof Array)) {\n          const singleAcct = moreThanRec[excess].pop();\n          owed.forEach(oweAmt => {\n            recommendText.push(`Transfer $${oweAmt} from ${singleAcct} to ${lessThanRec[oweAmt].pop()}.`);\n          })\n        }\n        else if (!(owed instanceof Array) && excess instanceof Array) {\n          const singleAcct = lessThanRec[owed].pop();\n          excess.forEach(excessAmt => {\n            recommendText.push(`Transfer $${excessAmt} from ${moreThanRec[excessAmt].pop()} to ${singleAcct}.`);\n          })\n        }\n        else { //both arrays\n          let currExcess = excess.pop();\n          let currOwed = owed.pop();\n\n          let currExcessAcct = moreThanRec[currExcess].pop();\n          let currOwedAcct = lessThanRec[currOwed].pop();\n\n          while (currExcess || currOwed) {\n            let deduct = Math.min(currExcess, currOwed);\n            recommendText.push(`Transfer $${deduct} from ${currExcessAcct} to ${currOwedAcct}.`);\n\n            currExcess = Math.floor((currExcess - deduct) * 1000)/1000;\n            currOwed = Math.floor((currOwed - deduct) * 1000)/1000;\n\n            if (currExcess) {\n              currOwed = owed.pop();\n              currOwedAcct = lessThanRec[currOwed].pop();\n            } else if (currOwed) {\n              currExcess = excess.pop();\n              currExcessAcct = moreThanRec[currExcess].pop();\n            } else break; //unnecessary break\n          }\n        }\n      })\n\n      setRecTransfers(recommendText);\n\n    }\n    else console.log(\"Review Errors\")\n  }\n\n  return (\n    \n    <div className=\"personalize-main-div\">\n      <div className=\"user-img\"></div>\n\n      <h1>Personalize Your Portfolio</h1>\n\n      <div className=\"personalize-div-wrapper\">\n        <div className=\"personalize-right\">\n          <section className=\"risk-section\">\n            { currPlan ? (\n              <div>\n                <h4 id=\"risk-section-header\">Risk Level {currPlan['Risk']}</h4>\n                { headers.map(ctg => (\n                  <div key={ctg}>\n                    <span>{ctg}</span>\n                    <span>{currPlan[ctg]}%</span>\n                  </div>\n                )) }\n              </div>\n            ) : <Link to=\"/plans\">Choose a plan that's right for you!</Link> }\n          </section>\n\n          { recTransfers.length ? (\n            <div className=\"recommended-trans-div\">\n              <h3>Recommended Transfers: </h3>\n              { recTransfers.map((text, idx) => (\n                  <p key={`text-${idx}`}>- {text}</p>\n              ))}\n            </div>\n          ) : null }\n        </div>\n\n        <div className=\"personalize-left\">\n          <div className=\"personalize-risk-section\">\n            <h3>Tell us about your current portfolio: </h3>\n            <form onSubmit={calculate}>\n              { headers.map(ctg => {\n                let recDiff;\n                let color; \n                let arrow; \n                let ctgErr = inputErrors[ctg] ? `${ctg}-input-errors` : \"\";\n                \n                if (Object.keys(recPortfolio).length) {\n                  recDiff = (recPortfolio[ctg] - userPortfolio[ctg]) ? recPortfolio[ctg] - userPortfolio[ctg] : null;\n                  color = recDiff > 0 ? \"green\" : \"red\";\n                  arrow = recDiff > 0 ? <i className=\"fas fa-arrow-up\"></i> : <i className=\"fas fa-arrow-down\"></i>;\n                }\n                return (\n                  <div key={ctg} className={`${ctg}-div personalize-input-div`}>\n                    <label htmlFor={ctg}>{ctg}</label>\n                    <input type=\"text\" \n                      onChange={updateAmount(ctg)}\n                      className={ctgErr}\n                    />\n                    { recDiff || recDiff === 0 ? <span className={`rec-${color}`}>{arrow} $ {Math.abs(recDiff).toFixed(2)}</span> : null }\n                  </div>\n                )\n              }) }\n\n              <button>Calculate My Plan!</button>\n            </form>\n            \n          </div>\n          { Object.keys(recPortfolio).length ? (\n\n            <div className=\"recommended-plan-div\">\n              <h3>Recommended Plan</h3>\n              {headers.map((ctg, idx) => {\n                return (\n                  <div key={`${ctg}-${idx}`}>\n                    <span>{ctg}:</span>\n                    <span>$ {recPortfolio[ctg]}</span>\n                  </div>\n                )\n              })}\n            </div>\n\n          ) : null }\n\n        </div>\n      </div>\n\n    </div>\n  )\n}\n\nexport default UserInfo;",["70","71"],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/PlansMain.js",["72"],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/reducers/plans_reducer.js",["73"],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/Portfolio.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/components/DonutChart.js",["74"],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/portfolio_actions.js",[],"/Users/keely/Desktop/career-prep/BrighterPlanning/frontend/src/actions/plan_actions.js",[],{"ruleId":"75","severity":1,"message":"76","line":26,"column":6,"nodeType":"77","endLine":26,"endColumn":8,"suggestions":"78"},{"ruleId":"79","severity":1,"message":"80","line":94,"column":9,"nodeType":"81","messageId":"82","endLine":94,"endColumn":19},{"ruleId":"83","replacedBy":"84"},{"ruleId":"85","replacedBy":"86"},{"ruleId":"75","severity":1,"message":"87","line":23,"column":6,"nodeType":"77","endLine":23,"endColumn":8,"suggestions":"88"},{"ruleId":"79","severity":1,"message":"89","line":1,"column":24,"nodeType":"81","messageId":"82","endLine":1,"endColumn":37},{"ruleId":"79","severity":1,"message":"90","line":3,"column":22,"nodeType":"81","messageId":"82","endLine":3,"endColumn":27},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'headers'. Either include it or remove the dependency array.","ArrayExpression",["91"],"no-unused-vars","'_subsetSum' is defined but never used.","Identifier","unusedVar","no-native-reassign",["92"],"no-negated-in-lhs",["93"],"React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.",["94"],"'RECEIVE_PLANS' is defined but never used.","'Point' is defined but never used.",{"desc":"95","fix":"96"},"no-global-assign","no-unsafe-negation",{"desc":"97","fix":"98"},"Update the dependencies array to be: [headers]",{"range":"99","text":"100"},"Update the dependencies array to be: [dispatch]",{"range":"101","text":"102"},[925,927],"[headers]",[732,734],"[dispatch]"]