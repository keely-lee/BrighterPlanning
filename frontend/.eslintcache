[{"/Users/keely/Desktop/BrighterPlanning/frontend/src/index.js":"1","/Users/keely/Desktop/BrighterPlanning/frontend/src/App.js":"2","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Portfolio.js":"3","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Splash.js":"4","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Root.js":"5","/Users/keely/Desktop/BrighterPlanning/frontend/src/store/store.js":"6","/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/root_reducer.js":"7","/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/entities_reducer.js":"8","/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js":"9","/Users/keely/Desktop/BrighterPlanning/frontend/src/actions/portfolio_actions.js":"10","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Navbar.js":"11","/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/plans_reducer.js":"12","/Users/keely/Desktop/BrighterPlanning/frontend/src/actions/plan_actions.js":"13","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/DonutChart.js":"14","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/PlansMain.js":"15","/Users/keely/Desktop/BrighterPlanning/frontend/src/components/UserCurrent.js":"16"},{"size":434,"mtime":1608867766424,"results":"17","hashOfConfig":"18"},{"size":1097,"mtime":1608867766422,"results":"19","hashOfConfig":"18"},{"size":1358,"mtime":1608867766422,"results":"20","hashOfConfig":"18"},{"size":367,"mtime":1608862636287,"results":"21","hashOfConfig":"18"},{"size":282,"mtime":1608417750379,"results":"22","hashOfConfig":"18"},{"size":453,"mtime":1608570164388,"results":"23","hashOfConfig":"18"},{"size":190,"mtime":1608410935676,"results":"24","hashOfConfig":"18"},{"size":274,"mtime":1608570164386,"results":"25","hashOfConfig":"18"},{"size":328,"mtime":1608570164388,"results":"26","hashOfConfig":"18"},{"size":904,"mtime":1608570164382,"results":"27","hashOfConfig":"18"},{"size":1479,"mtime":1608862636285,"results":"28","hashOfConfig":"18"},{"size":618,"mtime":1608829840489,"results":"29","hashOfConfig":"18"},{"size":465,"mtime":1608829840485,"results":"30","hashOfConfig":"18"},{"size":1561,"mtime":1608862636285,"results":"31","hashOfConfig":"18"},{"size":1372,"mtime":1608862636286,"results":"32","hashOfConfig":"18"},{"size":13833,"mtime":1608867766423,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1540778",{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67"},"/Users/keely/Desktop/BrighterPlanning/frontend/src/index.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/App.js",[],["68","69"],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Portfolio.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Splash.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Root.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/store/store.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/root_reducer.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/entities_reducer.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/portfolios_reducer.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/actions/portfolio_actions.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/Navbar.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/reducers/plans_reducer.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/actions/plan_actions.js",[],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/DonutChart.js",["70"],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/PlansMain.js",["71","72"],"/Users/keely/Desktop/BrighterPlanning/frontend/src/components/UserCurrent.js",["73","74"],"import React, { useState, useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { Link } from 'react-router-dom';\n\nimport '../stylesheets/userCurrent.css';\n\nfunction UserInfo() {\n  const currPlan = useSelector(state => state.entities.plans)[0];\n  const headers = currPlan ? Object.keys(currPlan).filter(hdrs => hdrs !== \"Risk\"): [];\n\n  // consider storing user's (valid entries) portfolio to store\n  const [ userPortfolio, setUserPortfolio ] = useState({});\n  const [ inputErrors, setInputErrors ] = useState({}); //modifying a set repeatedly will likely be costly\n\n  const [ recPortfolio, setRecPortfolio ] = useState({});\n  const [ recTransfers, setRecTransfers ] = useState([]);  \n\n\n  // componentDidMount - set base for user's info & recommended info\n  useEffect(() => {\n    const stateVars = {};\n    headers.forEach(ctg => {\n      stateVars[ctg] = 0.0;\n    })\n    setUserPortfolio(stateVars);\n  }, [])\n\n  function updateAmount(category) {\n    return e => {\n      //figure out regex solution if you have time\n      // const entered = e.currentTarget.value.replace(/,/g, \"\"); \n      let entered = e.currentTarget.value.split(\".\");\n\n      //when potentially fixing error, clear the error\n      if ( inputErrors[category] ) {\n        const tempErrors = Object.assign({}, inputErrors);\n        delete tempErrors[category];\n        setInputErrors(tempErrors);\n      }\n\n      //checks for valid number entered: max two decimal places, adjust for $ sign. Use better validity checks!!  //if length of decimal is more than 2, must be === 0 or parseFloat will make length less than 2 (meaning 0s only after 2nd decimal)\n      if (entered.length > 2 || (entered.length === 2 && isNaN(entered[1])) || (entered.length === 2 && entered[1].length > 2)) return setInputErrors(Object.assign({}, inputErrors, { [category]: true })) //consider using a set\n      if (entered[0][0] === \"$\") entered[0] = entered[0].slice(1);\n\n      // check validity: appropriate commas\n      for (let i = entered[0].length-4; i > 0; i-=4) { \n        if (entered[0][i] === \",\") entered[0] = entered[0].slice(0, i) + entered[0].slice(i+1); \n        else break;\n      }\n\n      if (!isNaN(entered.join(\".\"))) {\n        const newState = Object.assign({}, userPortfolio);\n        newState[category] = parseFloat(entered.join(\".\"));\n        setUserPortfolio(newState);\n      } \n      else {\n        setInputErrors(Object.assign({}, inputErrors, { [category]: true }))\n      }\n    }\n  }\n\n  function confirmValid() {\n    // confirm no errors, confirm at least one entry entered\n    // debugger\n    if (Object.keys(inputErrors).length || !Object.values(userPortfolio).some(ele => ele)) return false;\n    else return true;\n  }\n\n  function calculate(e) {\n    e.preventDefault();\n    if (confirmValid()) {\n      // Research accounting concepts\n\n      const total = Object.values(userPortfolio).reduce((subTotal, float) => {\n        if (float) return subTotal + parseFloat(float);\n        else return subTotal;\n      }, 0.0)\n\n      const makeRecPortfolio = {};\n      const recTrans = []; //Array of subarrays. \n        //First element of subarray = amount needed from fund(s); if int, matching subset of excess accounts; if array, partial transfers needed. \n        //Second element of subarray = excess amts; if int, matching subset of below value accts; if array, partial transfers needed.\n\n      // variables to be used for referencing which categories transfers will come from\n      const lessThanRec = {}; //key/value => amount needed: category      ---> none of these categories should transfer out\n      const moreThanRec = {}; //key/value => amount extra: category\n\n      let offAmounts = []; //To be sorted array of all amounts needed and excess\n      let largestNeg; //To be largest negative value (for quicker slicing & stop points)\n\n      headers.forEach(ctg => {\n        makeRecPortfolio[ctg] = Math.round(((parseInt(currPlan[ctg])/100 * total) + Number.EPSILON) * 100) / 100; //review this calculation for simplification\n\n        if (makeRecPortfolio[ctg] === userPortfolio[ctg]) return; //no transfers needed\n\n        if (makeRecPortfolio[ctg] > userPortfolio[ctg]) {\n          const setNumber = Math.round((makeRecPortfolio[ctg] - userPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (lessThanRec[setNumber]) lessThanRec[setNumber].push(ctg);\n          else lessThanRec[setNumber] = [ctg];\n\n          offAmounts.push(setNumber * -1); \n        }\n\n        else {\n          const setNumber = Math.round((userPortfolio[ctg] - makeRecPortfolio[ctg] + Number.EPSILON) * 100) / 100;\n          if (moreThanRec[setNumber]) moreThanRec[setNumber].push(ctg);\n          else moreThanRec[setNumber] = [ctg];\n          offAmounts.push(setNumber);\n        }\n\n      })\n\n      setRecPortfolio(makeRecPortfolio);\n\n      if (!Object.keys(moreThanRec).length) return; //no transfers needed - portfolio matches recommended plan\n\n\n      // insertionSort (quicker sort for small sized array)\n      function _insertionSort (inputArr) {\n        let length = inputArr.length;\n        for (let i = 1; i < length; i++) {\n          let key = inputArr[i];\n          let j = i-1;\n          while (j >= 0 && inputArr[j] > key) {\n            inputArr[j+1] = inputArr[j];\n            j = j-1;\n          }\n          inputArr[j+1] = key;\n        }\n        return inputArr;\n      }\n\n      //returns matching index or index of last element less than target\n      function _modBSearch(arr, target) {\n        if (target < arr[0]) return -1; //used to avoid split transfers until necessary\n        if (target > arr[arr.length-1]) return arr.length-1;\n\n        let mid;\n        let left = 0;\n        let right = arr.length;\n        \n\n        while (left < right) {\n          mid = Math.floor((left + right)/2);\n          if (arr[mid] === target) return mid;\n          if (arr[mid] < target) left = mid;\n          else right = mid-1;\n        }\n\n        //NEED TO FIX THIS\n        if (target === 0) {\n          if (arr[mid] > 0) return mid-1;\n        }\n\n        return mid;\n      } \n\n      _insertionSort(offAmounts); //sort off amounts\n      largestNeg = _modBSearch(offAmounts, 0); //initial declaration of largest negative\n\n      //find subset of sums\n      let sums = {}; //key:val => {length of smallest combo: array of subarray sums} \n      function _subsetSum(arr, target, partial = [], sum = 0, fixIdx = 0) { \n        if (sum < target) {\n          arr.forEach((num, i) => {\n            _subsetSum(arr.slice(i + 1), target, partial.concat([i + fixIdx]), sum + num, i+1)\n          })\n        }\n        else if (sum === target) {\n          fixIdx = 0;\n          if (sums[partial.length]) sums[partial.length].push(partial);\n          else sums[partial.length] = [partial];\n        }\n        else fixIdx = 0;\n      }\n\n\n      let posOffAmounts = offAmounts.slice(largestNeg+1); //avoid constant slicing if unnecessary\n      let negOffAmounts = offAmounts.slice(0, largestNeg+1);\n      \n      // first grab any matching differences\n      for (let i = 0; i <= largestNeg; i++) {\n        const current = Math.abs(offAmounts[i]);\n        const matchIndex = _modBSearch(posOffAmounts, current) + largestNeg + 1;\n\n        //NEED TO FIX MODBSEARCH\n        if (i === matchIndex) continue;\n\n        if (current === offAmounts[matchIndex]) {\n          recTrans.push([current, offAmounts[matchIndex]]);\n          offAmounts = offAmounts.slice(0, i).concat(offAmounts.slice(i+1, matchIndex)).concat(offAmounts.slice(matchIndex+1)); \n          //adjust for element being removed\n          largestNeg = largestNeg - 1; \n          negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          posOffAmounts = offAmounts.slice(largestNeg+1)\n          i--; \n        }\n      }\n\n      // next grab any owed combo with singular excess\n      let firstIteration = true;\n      while ((Object.keys(sums).length || firstIteration) && offAmounts.length > 0) {\n        firstIteration = false;\n\n        if (posOffAmounts.length === 1 || negOffAmounts.length === 1) {\n          debugger\n            if (negOffAmounts.length === 1) {\n              recTrans.push([Math.abs(negOffAmounts[0]), posOffAmounts]);\n            } else {\n              recTrans.push(negOffAmounts.map(amt => Math.abs(amt)), posOffAmounts[0]);\n            }\n        }\n\n        let bestNum = posOffAmounts.length;\n        let bestRec = [];\n        let bestExcessIdx = offAmounts.length-1;\n        let bestIndices = []; //for slicing\n\n        for (let i = offAmounts.length-1; i > largestNeg; i--) {\n          sums = {}; //reassign sums for each iteration\n\n          _subsetSum(negOffAmounts, offAmounts[i] * -1);\n\n          let cost = parseInt(Object.keys(sums)[0]);\n          if (bestNum > cost) {\n            bestNum = cost;\n            bestExcessIdx = i;\n            bestIndices = sums[cost].pop(); \n          }\n\n        }\n\n        // confirmed, best group is the best of this iteration\n        if (Object.keys(sums).length) {\n          for (let i = bestIndices.length-1; i >= 0; i--) {\n            bestRec.push(offAmounts[i]);\n            offAmounts = offAmounts.slice(0, i+1).concat(offAmounts.slice(i+1));\n          }\n\n          debugger\n          bestExcessIdx -= bestIndices.length; //adjust for sliced negs\n          recTrans.push([bestRec, offAmounts[bestExcessIdx]]); //can sum for offAmounts[bestExcessIdx], but use index for QA\n          offAmounts = offAmounts.slice(0, bestExcessIdx).concat(offAmounts.slice(bestExcessIdx+1));\n          largestNeg = largestNeg - bestIndices.length;\n          posOffAmounts = offAmounts.slice(largestNeg+1);\n          negOffAmounts = offAmounts.slice(0, largestNeg+1);\n          debugger \n        }\n      }\n\n\n      // max amount of excess combos will be limited to number of risk types (ie five)\n      // bestNumCombos = 2; bestNumCombos++ each iteration until reaching pos/neg length\n\n      //transfer to text values\n      let recommendText = [];\n      recTrans.forEach(subArr => {\n        let owed = subArr[0];\n        let excess = subArr[1];\n        debugger\n        if (!(owed instanceof Array) && !(excess instanceof Array)) {\n          debugger\n          recommendText.push(`Transfer $${owed} from ${moreThanRec[excess].pop()} ${lessThanRec[owed].pop()}.`)\n        }\n        else if (owed instanceof Array && !(excess instanceof Array)) {\n          const singleAcct = moreThanRec[excess].pop();\n          debugger\n          owed.forEach(oweAmt => {\n            recommendText.push(`Transfer $${oweAmt} from ${singleAcct} to ${lessThanRec[oweAmt].pop()}.`);\n          })\n        }\n        else if (!(owed instanceof Array) && excess instanceof Array) {\n          const singleAcct = lessThanRec[owed].pop();\n          debugger\n          excess.forEach(excessAmt => {\n            recommendText.push(`Transfer $${excessAmt} from ${moreThanRec[excessAmt].pop()} to ${singleAcct}.`);\n          })\n        }\n      })\n\n      setRecTransfers(recommendText);\n\n    }\n    else console.log(\"Review Errors\")\n  }\n\n  return (\n    \n    \n    <div className=\"personalize-main-div\">\n      {/* <img src=\"../images/user-current-img.jpg\" alt=\"personalize\" draggable=\"false\"/> */}\n\n      <h1>Personalize Your Portfolio</h1>\n\n      <div className=\"personalize-div-wrapper\">\n        <div className=\"personalize-right\">\n          <section className=\"risk-section\">\n            { currPlan ? (\n              <div>\n                <h4 id=\"risk-section-header\">Risk Level {currPlan['Risk']}</h4>\n                { headers.map(ctg => (\n                  <div key={ctg}>\n                    <span>{ctg}</span>\n                    <span>{currPlan[ctg]}%</span>\n                  </div>\n                )) }\n              </div>\n            ) : <Link to=\"/plans\">Choose a plan that's right for you!</Link> }\n          </section>\n\n          { recTransfers.length ? (\n            <div className=\"recommended-trans-div\">\n              <h3>Recommended Transfers: </h3>\n              { recTransfers.map(text => (\n                  <p>- {text}</p>\n              ))}\n            </div>\n          ) : null }\n        </div>\n\n        <div className=\"personalize-left\">\n          <div className=\"personalize-risk-section\">\n            <h3>Tell us about your current portfolio: </h3>\n            <form onSubmit={calculate}>\n              { headers.map(ctg => {\n                let recDiff;\n                let color; \n                let arrow; \n                if (Object.keys(recPortfolio).length) {\n                  recDiff = (recPortfolio[ctg] - userPortfolio[ctg]) ? recPortfolio[ctg] - userPortfolio[ctg] : null;\n                  color = recDiff > 0 ? \"green\" : \"red\";\n                  arrow = recDiff > 0 ? <i className=\"fas fa-arrow-up\"></i> : <i className=\"fas fa-arrow-down\"></i>;\n                }\n                return (\n                  <div key={ctg} className={`${ctg}-div personalize-input-div`}>\n                    <label htmlFor={ctg}>{ctg}</label>\n                    <input type=\"text\"\n                      onChange={updateAmount(ctg)}\n                    />\n                    { recDiff || recDiff === 0 ? <span className={`rec-${color}`}>{arrow} $ {Math.abs(recDiff).toFixed(2)}</span> : null }\n                  </div>\n                )\n              }) }\n\n              <button>Calculate My Plan!</button>\n            </form>\n            \n          </div>\n          { Object.keys(recPortfolio).length ? (\n\n            <div className=\"recommended-plan-div\">\n              <h3>Recommended Plan</h3>\n              {headers.map((ctg, idx) => {\n                return (\n                  <div key={`${ctg}-${idx}`}>\n                    <span>{ctg}:</span>\n                    <span>$ {recPortfolio[ctg]}</span>\n                  </div>\n                )\n              })}\n            </div>\n\n          ) : null }\n\n        </div>\n      </div>\n\n    </div>\n  )\n}\n\nexport default UserInfo;",{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","severity":1,"message":"80","line":3,"column":22,"nodeType":"81","messageId":"82","endLine":3,"endColumn":27},{"ruleId":"79","severity":1,"message":"83","line":1,"column":17,"nodeType":"81","messageId":"82","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":21,"column":6,"nodeType":"86","endLine":21,"endColumn":8,"suggestions":"87"},{"ruleId":"79","severity":1,"message":"88","line":2,"column":23,"nodeType":"81","messageId":"82","endLine":2,"endColumn":34},{"ruleId":"84","severity":1,"message":"89","line":26,"column":6,"nodeType":"86","endLine":26,"endColumn":8,"suggestions":"90"},"no-native-reassign",["91"],"no-negated-in-lhs",["92"],"no-unused-vars","'Point' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.","ArrayExpression",["93"],"'useDispatch' is defined but never used.","React Hook useEffect has a missing dependency: 'headers'. Either include it or remove the dependency array.",["94"],"no-global-assign","no-unsafe-negation",{"desc":"95","fix":"96"},{"desc":"97","fix":"98"},"Update the dependencies array to be: [dispatch]",{"range":"99","text":"100"},"Update the dependencies array to be: [headers]",{"range":"101","text":"102"},[639,641],"[dispatch]",[938,940],"[headers]"]